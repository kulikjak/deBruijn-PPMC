

/*void Graph_Insert_L(GraphRef Graph__, uint32_t pos__, bool val__) {

  if (pos__ > MEMORY_GET_ANY(Graph__->mem_, Graph__->root_)->p_)
    FATAL("Index out of range");

  STACK_CLEAN();

  VERBOSE( fprintf(stderr, "Inserting value %d on position %u\n", val__, pos__); )

  // traverse the tree and enter correct leaf
  int32_t current = Graph__->root_;
  STACK_PUSH(current);

  while (!IS_LEAF(current)) {
    // update p and r counters as we are traversing the structure
    node_32e* node = MEMORY_GET_NODE(Graph__->mem_, current);
    node->p_ += 1;
    node->rL_ += val__;

    uint32_t temp = MEMORY_GET_ANY(Graph__->mem_, node->left_)->p_;
    if (temp >= pos__) {
      current = node->left_;
    } else {
      pos__ -= temp;
      current = node->right_;
    }

    STACK_PUSH(current);
  }

  leaf_32e* current_ref = MEMORY_GET_LEAF(Graph__->mem_, current);
  if (current_ref->p_ < 32) {
    INSERT_BITX(current_ref, pos__, val__);

  } else {
    VERBOSE( fprintf(stderr, "Splitting full node\n"); )

    int32_t node = Memory_new_node(Graph__->mem_);
    node_32e* node_ref = MEMORY_GET_NODE(Graph__->mem_, node);

    node_ref->p_ = 33;
    node_ref->rL_ = current_ref->rL_ + val__;

    // allocate new right leaf and reuse current as left leaf
    node_ref->right_ = Memory_new_leaf(Graph__->mem_);
    node_ref->left_ = current;

    // initialize new right node
    leaf_32e* right_ref = MEMORY_GET_LEAF(Graph__->mem_, node_ref->right_);
    right_ref->vectorL_ = (current_ref->vectorL_ & (0xFFFF)) << 16;
    right_ref->p_ = 16;

    // calculate rank on newly created node
    //RANK16(right_ref)

    // initialize (reuse) old leaf as left one
    current_ref->vectorL_ = current_ref->vectorL_ & (0xFFFF0000);
    current_ref->p_ = 16;
    current_ref->rL_ -= right_ref->rL_;

    // now insert bit into correct leaf
    if (pos__ <= 16) {
      INSERT_BITX(current_ref, pos__, val__);
    } else {
      INSERT_BITX(right_ref, pos__ - 16, val__);
    }

    // finally exchange pointers to new node
    if (STACK_GET_PARENT() == -1) {
      Graph__->root_ = node;
    } else {
      NodeRef parent = MEMORY_GET_NODE(Graph__->mem_, STACK_GET_PARENT());
      if (parent->left_ == current)
        parent->left_ = node;
      else
        parent->right_ = node;
    }
  }
}*/

/*
 * Rank given symbol value in WT_Struct.
 *
 * @param  Graph__  Reference to WT_Struct object.
 * @param  pos__  Query position.
 * @param  symb__  Query symbol value.
 */
/*int32_t Graph_WRank(GraphRef Graph__, uint32_t pos__, int8_t symb__) {
  int32_t temp;

  switch (symb__) {
    case 'A':
      temp = pos__ - Graph_WRank_Top(*Graph__, pos__);
      return temp - Graph_WRank_Left(*Graph__, temp);
    case 'C':
      temp = pos__ - Graph_WRank_Top(*Graph__, pos__);
      return Graph_WRank_Left(*Graph__, temp);
    case 'G':
      temp = Graph_WRank_Top(*Graph__, pos__);
      return temp - Graph_WRank_Right(*Graph__, temp);
    case 'T':
      temp = Graph_WRank_Top(*Graph__, pos__);
      temp = Graph_WRank_Right(*Graph__, temp);
      return temp - Graph_WRank_Bottom(*Graph__, temp);
    case '$':
      temp = Graph_WRank_Top(*Graph__, pos__);
      temp = Graph_WRank_Right(*Graph__, temp);
      return Graph_WRank_Bottom(*Graph__, temp);
  }
  FATAL("Unknown symbol");
  return 0;
}*/




